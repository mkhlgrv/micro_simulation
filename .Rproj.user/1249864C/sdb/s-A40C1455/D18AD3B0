{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Микросимуляция\"\nauthor: Finn the Human\noutput: html_notebook\n---\n\n# Введение \nВ курсе микроэкономики вы уже познакомились с базовой теорией производителя. Сегодня мы вспомним эту теорию и с её помощью займёмся симуляцией рыночного равновесия, а ещё посмотрим, как пользоваться R Notebook и некоторыми пакетами в R. \n\nПисать мы будем в простом языке разметки markdown, который интегририрован в R и легко компилируется в html (и чуть сложнее --- в pdf). Перейдём к следующему разделу и, чтобы выделить заголовок, поставим знак \\# (количество \\# соответствует уровню заголовка).\n\n# Теория + LaTeX\nМикроэкономическая теория предполагает, что фирма максимизирует свою прибыль, при этом она сталкивается с ограничениями. Ограничений несколько, поэтому мы будем использовать для их перечисления нумерованный список.\n\n1. Производственная функция, которая показывает максимальное количество выпуска, которая фирма может произвести в зависимости от количества используемых факторов производства. Вставим уравнение, для этого воспользуемся синтаксисом LaTeX'а: \n  $$ y = f(x), $$\n  где: \n  * $y$ --- это выпуск фирмы,\n  * $x$ --- фактор производства.\n  Стандартная функция $f$ имеет положительную первую производную $f'>0$ и отрицательную вторую производную $f^{(2)}>0$.\n\n\n2. Цена на продукцию фирмы. В базовой модели фирма вопринимает цену как заданную (она является price-taker'ом).\n\nЗапишем функцию прибыли --- разницу между выручкой и издержками.:\n$$ \\pi = p \\cdot y - w \\cdot x,$$\nгде: \n  * $\\pi$ --- это прибыль,\n  * $p$ --- цена продукции,\n  * $w$ --- цена фактора производства.\n  \nРешая задачу минимизации издержек при любом заданном выпуске, мы получаем функцию издержек $TC(y)$.\n\nМожно записать прибыль в следующем виде:\n$$ \\pi = p \\cdot y - TC(y)$$\nИздержки можно разложить на постоянные $FC$ (не зависят от объема выпуска) и переменные $VC$ (зависят от объёма выпуска): \n\n$$TC(y) = FC + VC(y) $$. \n\nПоделим последнее равенство на $y$ и получим разложение средних издержек $AC$ на средние постоянные $AFC$ и средние переменные издержки $AVC$. \nМикроэкономическая теория предполагает, что фирме имеет смысл существовать в краткрочном периоде, если выручка покрывает хотя бы переменные издержки (т.е. $p \\cdot y \\geq VC \\Leftrightarrow  p \\geq AVC $), а в долгосрочном периоде (т.е., когда все издержки переменные) --- только если прибыль неотрицательна: $p \\cdot y \\geq TC \\Leftrightarrow p \\geq AC$.\n\nТогда, решая задачу максимизации прибыли фирмы (возьмём производную по $y$), получим в краткосрочном периоде:\n$$\nMC = p ,\\text{если } p \\geq AVC,   \n$$ \nа в долгосрочном периоде:\n$$\nMC = p,\\text{если } p \\geq AC.   \n$$ \n\n## Симуляция\n\nВспомнили теорию --- реализуем её в R. Симулируем рынок мёда и попробуем спрогнозировать параметры равновесия на рынке:\n* объём производства $q$,\n* количество фирм $n$.\nВ качестве бонуса посмотрим, что произойдёт, если появится налог на продажу мёда.\n\n\nЧтобы сделать хороший прогноз, было бы неплохо владеть аппаратом матстатистики, но есть и более простой способ  --- надо тупо прогнать одну и ту же модель, случайным образом меняя параметры, много-много раз и посмотреть, что получится. Это называется метод Монте-Карло.\n\nПусть известно, что цена на мёд задана заранее как $a$, но может меняться из-за присутствия в ней **шока спроса** случайной величины $\\varepsilon$ (об этом позже):\n\n$$\np = a + \\varepsilon.\n$$\n\nПусть на рынке может быть максимально $N$ фирм. Функция предельных издержек $MC_i$ для каждой фирмы $i, i  = \\overline{1,N}$ имеет следующий вид:\n$$\nMC_i = c + d*q_i + v_i\n$$\nгде:\n* $с, d$ --- заранее заданные, общие для каждой из фирм параметры, \n* $q_i$ --- объём производства фирмы $i$\n* $v_i$ --- **шок предложения** для фирмы $i$, случайная величина.\n\n### Случайные величины\nМы ввели величины $v_i$ и $\\varepsilon$ --- случайные ошибки --- для отражения всех факторов, которые влияют на спрос и предложение и которые мы не стали учитывать в модели (и не смогли бы!). Разумно выбрать эти величины **нормально распределёнными**. Не будем углубляться в теорию, просто посмотрим, как выглядит нормальное распределение:\n```{r}\nset.seed(1) # правило хорошего тона: установить seed при работе со случайными величинами\nlibrary(dplyr)\nlibrary(ggplot2) # графика\nlibrary(latex2exp)\nx <- seq(-3,3,0.1)\ndf_0_1 <- data.frame(x = x, y = dnorm(x, mean =0, sd = 1), type = 1)\ndf_0_0.5 <- data.frame(x = x, y = dnorm(x, mean = 0, sd = 0.5), type = 2)\ndf_1_1 <- data.frame(x = x, y = dnorm(x, mean = 1, sd = 1), type = 3)\ndf <- bind_rows(df_0_1, df_0_0.5, df_1_1)\ndf$type <- as.factor(df$type)\nggplot(data = df, aes(x = x, y = y, group = type, colour = type)) +\n  geom_line() +\n  xlim(-3,3) +\n  ggtitle(data.frame(x = x, y = dnorm(x)))+\n  xlab(\"x\") +\n  ylab(\"y\") +\n  scale_colour_discrete(name = \"Типы\",\n                   labels = c(TeX(\"$ \\\\mu = 0,  \\\\sigma = 1$\"),\n                              TeX(\"$ \\\\mu = 0, \\\\sigma = 0.5$\"),\n                              TeX(\"$ \\\\mu = 0, \\\\sigma = 1$\")))\n\n```\nС высоким шансом случайная величина принимает значения, близкие к центру, и наоборот. Нормальное распределение зависит от двух параметров --- **матожидания** $\\mu$ (отвечает за смещение по оси x) и стандартного отклонения $\\sigma$ (отвечает за разброс --- чем меньше, тем более сжат график).\n\n# Сама симуляция\n\nМы проведём $k = 500$ симуляций для базовых значений параметров.\n```{r}\nset.seed(1)\nk <- 500\nN <- 50\na <- 20\nc <- 5\nd <- 1\nsigma_eps <- 1\nsigma_v <- 0.5\ndf <- data.frame(epsilon =\n                   rnorm(k,0, sigma_eps))\nfor(j in 1:N){\n    df <- cbind(df,rnorm(k,0, sigma_v))\n}\n\nfor(i in 1:k){\n  e_i <- df[i,1]\n  v_i <- sort(df[i,-1])\n  while()\n}\n```\n\n",
    "created" : 1544471540449.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3667172816",
    "id" : "D18AD3B0",
    "lastKnownWriteTime" : 1544486941,
    "last_content_update" : 1544486941298,
    "path" : "C:/mkhlgrv/micro_simulation/notebook.Rmd",
    "project_path" : "notebook.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "tempName" : "Untitled2"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}